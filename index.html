
   <!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Duckcraft Raycast Underground</title>
<style>
  html,body {margin:0;height:100%;background:#000;}
  canvas {display:block;width:100vw;height:100vh;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
canvas.width=innerWidth; canvas.height=innerHeight;

const MAP_W=32, MAP_H=32, DEPTH=3;
const EMPTY=0, GRASS=1, STONE=2, ORE=3;

// Generate layered world
const world = Array.from({length:DEPTH}, (_,z)=>
  Array.from({length:MAP_H}, (_,y)=>
    Array.from({length:MAP_W}, (_,x)=>{
      if(z===0) return Math.random()<0.2?STONE:GRASS;
      if(z===1) return Math.random()<0.3?ORE:STONE;
      return STONE;
    })
  )
);

const player={x:MAP_W/2,y:MAP_H/2,z:0,angle:0,fov:Math.PI/3};

// Input
const keys=new Set();
addEventListener('keydown',e=>{
  keys.add(e.key.toLowerCase());
  if(e.key==='ArrowDown'&&e.shiftKey) if(player.z<DEPTH-1) player.z++;
  if(e.key==='ArrowUp'&&e.shiftKey) if(player.z>0) player.z--;
});
addEventListener('keyup',e=>keys.delete(e.key.toLowerCase()));

// Movement
function update(dt){
  let dx=0,dy=0;
  if(keys.has('w')) dy-=1;
  if(keys.has('s')) dy+=1;
  if(keys.has('a')) dx-=1;
  if(keys.has('d')) dx+=1;
  const nx=player.x+dx*dt*5, ny=player.y+dy*dt*5;
  if(nx>=0&&ny>=0&&nx<MAP_W&&ny<MAP_H && world[player.z][Math.floor(ny)][Math.floor(nx)]===EMPTY){
    player.x=nx; player.y=ny;
  }
}

// Raycasting
function castRay(rayAngle){
  const sin=Math.sin(rayAngle), cos=Math.cos(rayAngle);
  let mapX=Math.floor(player.x), mapY=Math.floor(player.y);
  const deltaDistX=Math.abs(1/(cos||1e-6)), deltaDistY=Math.abs(1/(sin||1e-6));
  let stepX,stepY,side,sideDistX,sideDistY;
  if(cos<0){stepX=-1;sideDistX=(player.x-mapX)*deltaDistX;} else {stepX=1;sideDistX=(mapX+1-player.x)*deltaDistX;}
  if(sin<0){stepY=-1;sideDistY=(player.y-mapY)*deltaDistY;} else {stepY=1;sideDistY=(mapY+1-player.y)*deltaDistY;}
  let hit=0,tile=EMPTY;
  while(!hit && mapX>=0&&mapY>=0&&mapX<MAP_W&&mapY<MAP_H){
    if(sideDistX<sideDistY){sideDistX+=deltaDistX;mapX+=stepX;side=0;}
    else {sideDistY+=deltaDistY;mapY+=stepY;side=1;}
    tile=world[player.z][mapY][mapX];
    if(tile!==EMPTY) hit=1;
  }
  const dist=hit?(side===0?(mapX-player.x+(1-stepX)/2)/cos:(mapY-player.y+(1-stepY)/2)/sin):1e6;
  return {dist,tile,side};
}

function render(){
  ctx.fillStyle='#87ceeb'; ctx.fillRect(0,0,canvas.width,canvas.height/2);
  ctx.fillStyle='#444'; ctx.fillRect(0,canvas.height/2,canvas.width,canvas.height/2);
  const numRays=canvas.width;
  const start=player.angle-player.fov/2;
  for(let x=0;x<numRays;x++){
    const rayAngle=start+(x/numRays)*player.fov;
    const {dist,tile,side}=castRay(rayAngle);
    if(tile!==EMPTY){
      const corrected=dist*Math.cos(rayAngle-player.angle);
      const h=Math.min(canvas.height,canvas.height/corrected);
      const yTop=canvas.height/2-h/2;
      ctx.fillStyle=tile===GRASS?'#3b3':tile===STONE?'#888':'#0ff';
      ctx.fillRect(x,yTop,1,h);
    }
  }
}

// Loop
let last=performance.now();
function loop(now){
  const dt=(now-last)/1000; last=now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
